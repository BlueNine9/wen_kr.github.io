<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络流相关模板]]></title>
    <url>%2F2018%2F04%2F08%2FNWF%2F</url>
    <content type="text"><![CDATA[网络流 Dinic:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980struct edge&#123; int v,nxt,flow;&#125;e[5000005];int ecnt,head[100005];void adde(int u,int v,int flow)&#123; e[ecnt].v = v; e[ecnt].nxt = head[u]; head[u] = ecnt; e[ecnt].flow = flow; ecnt++;&#125;int s,t;int dep[100050];bool bfs()&#123; queue&lt;int&gt; que; memset(dep,-1,sizeof(dep)); dep[t] = 0; que.push(t); while(!que.empty()) &#123; int u = que.front(); que.pop(); if(u == s) return true; for(int i = head[u];~i;i = e[i].nxt) &#123; int v = e[i].v; if(e[i ^ 1].flow &amp;&amp; dep[v] == -1) &#123; dep[v] = dep[u] + 1; //printf("%d %d\n",v,u); que.push(v); &#125; &#125; &#125; return false;&#125;int curedge[100050];int dfs(int s,int t,int flow)&#123; if(s == t) return flow; int delta = flow; for(int i = head[s];~i;i = e[i].nxt) &#123; int v = e[i].v; if(dep[v] == dep[s] - 1 &amp;&amp; e[i].flow) &#123; //printf("%d %d\n",s,v); int g = dfs(v,t,min((int)e[i].flow,delta)); delta -= g; e[i].flow -= g; e[i ^ 1].flow += g; if(!delta) return flow; &#125; &#125; dep[s] = -1; return flow - delta;&#125;int dinic()&#123; int ans = 0; while(bfs()) &#123; memcpy(curedge,head,sizeof(head)); ans += dfs(s,t,0x3f3f3f3f); &#125; return ans;&#125; 费用流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485struct edge&#123; int v,nxt,flow,w;&#125;e[50000];void adde(int u,int v,int flow,int w)&#123; e[ecnt].v = v; e[ecnt].nxt = head[u]; e[ecnt].w = w; head[u] = ecnt; e[ecnt].flow = flow; ecnt++;&#125;bool spfa()&#123; deque&lt;int&gt; que; memset(dep,0x3f3f3f3f,sizeof(dep)); memset(inq,0,sizeof(inq)); dep[t] = 0; que.push_back(t); while(!que.empty()) &#123; int u = que.front(); que.pop_front(); for(int i = head[u];~i;i = e[i].nxt) &#123; int v = e[i].v; if(e[i ^ 1].flow &amp;&amp; dep[u] - e[i].w &lt; dep[v]) &#123; dep[v] = dep[u] + e[i ^ 1].w; if(!inq[v]) &#123; if(que.empty() || dep[v] &lt; dep[que.front()]) que.push_front(v); else que.push_back(v); inq[v] = true; &#125; &#125; &#125; inq[u] = false; &#125; return dep[s] &lt; 1061109567;&#125;int dfs(int s,int t,int flow)&#123; if(s == t) return flow; int delta = flow; vis[s] = true; for(int i = head[s];~i;i = e[i].nxt) &#123; int v = e[i].v; if(!vis[v] &amp;&amp; dep[v] == dep[s] - e[i].w &amp;&amp; e[i].flow) &#123; //printf("%d %d\n",s,v); int g = dfs(v,t,min((int)e[i].flow,delta)); delta -= g; ans += g * e[i].w; e[i].flow -= g; e[i ^ 1].flow += g; if(!delta) return flow; &#125; &#125; return flow - delta;&#125;int dinic()&#123; int anss = 0; while(spfa()) &#123; vis[t] = 1; while(vis[t]) &#123; memset(vis,0,sizeof(vis)); anss += dfs(s,t,0x3f3f3f3f); &#125; &#125; return anss;&#125; 最终结果为ans 无源汇上下界网络流(只有建图)1234567891011121314151617181920212223242526memset(head,-1,sizeof(head));memset(inv,0,sizeof(inv));memset(ouv,0,sizeof(ouv));ecnt = 0;s = 0,t = 50050;scanf("%lld%lld",&amp;n,&amp;m);for(int i = 1;i &lt;= m; ++ i)&#123; int fr,to,liml,limr; scanf("%d%d%d%d",&amp;fr,&amp;to,&amp;liml,&amp;limr); adde(fr,to,limr - liml,liml); adde(to,fr,0,liml); inv[to] += liml; ouv[fr] += liml;&#125;int qsum = 0;for(int i = 1;i &lt;= n; ++ i)&#123; if(inv[i] &gt; ouv[i]) adde(s,i,inv[i] - ouv[i],0),adde(i,s,0,0),qsum += inv[i]-ouv[i]; else adde(i,t,ouv[i]-inv[i],0),adde(t,i,0,0);&#125;long long ans = 0;if(dinic() == qsum) 有解;else 无解; 有源汇上下界网络流$ss$ $tt$为源汇$s$ $t$为超级源点汇点1234567891011121314151617for(int i = 0;i &lt;= tt; ++ i)&#123; if(inf[i] &gt; ouf[i]) adde(s,i,inf[i]-ouf[i]),adde(i,s,0),sum += inf[i] - ouf[i]; else adde(i,t,ouf[i]-inf[i]),adde(t,i,0);&#125;int tot1 = dinic();adde(tt,ss,0x3f3f3f3f);adde(ss,tt,0);int tot2 = dinic();if(tot1 + tot2 == sum)&#123; printf("%d\n",e[ecnt - 1].flow);&#125;else printf("impossible\n");]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>网络流</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串相关模板]]></title>
    <url>%2F2018%2F04%2F08%2FStr%2F</url>
    <content type="text"><![CDATA[KMP:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char a[1000050],b[1000050];int nxt[1000050];int main()&#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%s %s",a + 1,b + 1); int len = strlen(a + 1); memset(nxt,0,sizeof(nxt)); for(int i = 2;i &lt;= len; ++ i) &#123; int lst = nxt[i - 1]; while(a[lst + 1] != a[i] &amp;&amp; lst) lst = nxt[lst]; if(a[lst + 1] == a[i]) lst ++; nxt[i] = lst; &#125; int cur = 0; int ans = 0; int len2 = strlen(b + 1); for(int i = 1;i &lt;= len2; ++ i) &#123; while(b[i] != a[cur + 1] &amp;&amp; cur) cur = nxt[cur]; if(a[cur + 1] == b[i]) cur ++; if(cur == len) ans ++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; Trie树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int son[5000050][10];int val[5000050];struct Trie&#123; int cnt; void init() &#123; memset(son[0],0,sizeof(son[0])); val[0] = 0; cnt = 0; &#125; void init_pos(int pos) &#123; memset(son[pos],0,sizeof(son[pos])); val[pos] = 0; &#125; bool insert(char *s) &#123; int cur = 0; int len = strlen(s + 1); int u; for(int i = 1;i &lt;= len; ++ i) &#123; int u = son[cur][s[i] - '0']; if(u == 0) &#123; u = ++cnt; init_pos(u); son[cur][s[i] - '0'] = cnt; cur = u; &#125; else &#123; if(val[u]) return false; cur = u; &#125; &#125; val[cur] ++; return true; &#125; bool work(int rt) &#123; bool yn; if(val[rt]) yn = true; else yn = false; for(int i = 0;i &lt;= 9; ++ i) &#123; int v = son[rt][i]; if(v != 0) &#123; if(yn) return false; else if(!work(v)) return false; &#125; &#125; return true; &#125;&#125;Tr; AC自动机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int son[3000050][26],val[3000050];int cnt;int fail[3000050];int ans;bool vis[3000050];struct Trie_AC&#123; int get_id(char c) &#123; return c - 'a'; &#125; void init(int pos) &#123; memset(son[pos],0,sizeof(son[pos])); val[pos] = 0; &#125; void insert(char *c,int num) &#123; int len = strlen(c); int u = 0; for(int i = 0;i &lt; len; ++ i) &#123; int v = get_id(c[i]); int tmp = u; u = son[u][v]; if(u == 0) &#123; init(++cnt); son[tmp][v] = cnt; u = cnt; &#125; &#125; val[u]++; &#125; void build() &#123; queue&lt;int&gt; q; fail[0] = 0; for(int i = 0;i &lt; 26; ++ i) if(son[0][i]) &#123; q.push(son[0][i]); fail[son[0][i]] = 0; &#125; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = 0;i &lt; 26; ++ i) &#123; int f = fail[u]; if(!son[u][i]) continue; while(f &amp;&amp; !son[f][i]) f = fail[f]; fail[son[u][i]] = son[f][i]; //lst[son[u][i]] = val[fail[son[u][i]]] ? fail[son[u][i]] : lst[fail[son[u][i]]]; q.push(son[u][i]); &#125; &#125; &#125; void query(char *c) &#123; int len = strlen(c); int cur = 0; for(int i = 0;i &lt; len; ++ i) &#123; int v = get_id(c[i]); while(cur &amp;&amp; !son[cur][v]) cur = fail[cur]; cur = son[cur][v]; int tmp = cur; while(tmp) &#123; ans += val[tmp]; val[tmp] = 0; tmp = fail[tmp]; &#125; &#125; &#125;&#125;Trie; 带dp的AC自动机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int son[2500][2];int lst[205],fail[250];int val[205];int cnt;int dp[101][101][202][4];int n,m;const int mod = 1000000007;struct Trie&#123; int get_id(char c) &#123; return c == 'R'; &#125; void init(int pos) &#123; son[pos][0] = son[pos][1] = 0; val[pos] = 0; &#125; void insert(char* c,int id) &#123; int len = strlen(c); int u = 0; for(int i = 0;i &lt; len; ++ i) &#123; int v = son[u][get_id(c[i])]; if(!v) &#123; son[u][get_id(c[i])] = ++cnt; init(cnt); u = cnt; &#125; else u = v; &#125; val[u] |= id; &#125; void Build() &#123; queue &lt;int&gt; q; lst[0] = fail[0] = 0; for(int i = 0;i &lt;= 1; ++ i) &#123; int v = son[0][i]; if(v) &#123; lst[v] = fail[v] = 0; q.push(v); &#125; &#125; while(!q.empty()) &#123; int u = q.front();q.pop(); val[u] |= val[lst[u]]; for(int i = 0;i &lt; 2; ++ i) &#123; int v = son[u][i]; if(!v) &#123; son[u][i] = son[fail[u]][i]; continue; &#125; int f = fail[u]; while(f &amp;&amp; !son[f][i]) f = fail[f]; fail[v] = son[f][i]; lst[v] = val[fail[v]] ? fail[v] : lst[fail[v]]; q.push(v); &#125; &#125; &#125; void Do_DP() &#123; for(int i = 0;i &lt;= n; ++ i) for(int j = 0;j &lt;= m; ++ j) for(int k = 0;k &lt;= cnt; ++ k) for(int l = 0;l &lt; 4; ++ l) dp[i][j][k][l] = 0; dp[0][0][0][0] = 1; for(int i = 0;i &lt;= n; ++ i) for(int j = 0;j &lt;= m; ++ j) for(int k = 0;k &lt;= cnt; ++ k) for(int l = 0;l &lt; 4; ++ l) &#123; if(dp[i][j][k][l] == 0) continue; if(i &lt; n) dp[i + 1][j][son[k][1]][l | val[son[k][1]]] += dp[i][j][k][l],dp[i + 1][j][son[k][1]][l | val[son[k][1]]] %= mod; if(j &lt; m) dp[i][j + 1][son[k][0]][l | val[son[k][0]]] += dp[i][j][k][l],dp[i][j + 1][son[k][0]][l | val[son[k][0]]] %= mod; &#125; long long qsum = 0; for(int i = 0;i &lt;= cnt; ++ i) qsum += dp[n][m][i][3],qsum %= mod; printf("%lld\n",qsum); &#125;&#125;Trie; 带矩阵优化的AC自动机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143long long son[2500][26];long long lst[205],fail[250];long long val[205];long long cnt;long long n,m;const long long mod = 1000000007;struct Matrix&#123; unsigned long long sum[55][55]; long long sz; void init(long long _sz) &#123; sz = _sz; for(long long i = 0;i &lt;= sz; ++ i) for(long long j = 0;j &lt;= sz; ++ j) sum[i][j] = 0; &#125; Matrix operator * (const Matrix&amp; a) &#123; Matrix c; c.init(a.sz); long long lim = c.sz; for(long long i = 0;i &lt;= sz; ++ i) for(long long j = 0;j &lt;= sz; ++ j) for(long long k = 0;k &lt;= sz; ++ k) c.sum[i][j] += a.sum[k][j] * sum[i][k]; return c; &#125;&#125;;Matrix qpow(Matrix A,long long tms)&#123; if(tms == 1) return A; else if(tms == 0) &#123; Matrix E; E.init(A.sz); for(int i = 0;i &lt;= A.sz; ++ i) E.sum[i][i] = 1; return E; &#125; Matrix tmp = A; tms -= 1; while(tms) &#123; if(tms &amp; 1) tmp = tmp * A; A = A * A; tms &gt;&gt;= 1; &#125; return tmp;&#125;unsigned long long qpow(unsigned long long a,long long tms)&#123; unsigned long long tmp = 1; while(tms) &#123; if(tms &amp; 1) tmp *= a; a *= a; tms &gt;&gt;= 1; &#125; return tmp;&#125;struct Trie&#123; long long get_id(char c) &#123; return c - 'a'; &#125; void init(long long pos) &#123; memset(son[pos],0,sizeof(son[pos])); val[pos] = 0; &#125; void insert(char* c,long long id) &#123; long long len = strlen(c); long long u = 0; for(long long i = 0;i &lt; len; ++ i) &#123; long long v = son[u][get_id(c[i])]; if(!v) &#123; son[u][get_id(c[i])] = ++cnt; init(cnt); u = cnt; &#125; else u = v; &#125; val[u] |= id; &#125; void Build() &#123; queue &lt;long long&gt; q; lst[0] = fail[0] = 0; for(long long i = 0;i &lt;= 25; ++ i) &#123; long long v = son[0][i]; if(v) &#123; lst[v] = fail[v] = 0; q.push(v); &#125; &#125; while(!q.empty()) &#123; long long u = q.front();q.pop(); val[u] |= val[lst[u]]; for(long long i = 0;i &lt; 26; ++ i) &#123; long long v = son[u][i]; if(!v) &#123; son[u][i] = son[fail[u]][i]; continue; &#125; long long f = fail[u]; while(f &amp;&amp; !son[f][i]) f = fail[f]; fail[v] = son[f][i]; lst[v] = val[fail[v]] ? fail[v] : lst[fail[v]]; q.push(v); &#125; &#125; &#125; void get_mat(Matrix&amp; mat) &#123; for(long long i = 0;i &lt;= cnt; ++ i) &#123; if(val[i]) continue; for(long long j = 0;j &lt; 26; ++ j) &#123; long long k = son[i][j]; if(val[k]) continue; mat.sum[i][k] ++; &#125; &#125; for(long long i = 0;i &lt;= cnt + 1; ++ i) mat.sum[i][cnt] = 1; &#125;&#125;Trie;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Many Hougong题解]]></title>
    <url>%2F2018%2F04%2F07%2FHow-many-hougong%2F</url>
    <content type="text"><![CDATA[题目简述给定一串长度为 $n$ 的序列，每个点上有一个权值 $a_i$ ，现在你需要处理 $q$ 个操作，有以下两种操作： $1$ $val$ 表示你需要构造一个序列，序列中每一个元素 $seq_i$ 小于等于 $a_i$ 且大于 $0$，问所有合法的序列中 $val$ 出现了几次。 $2$ $pos$ $val$ 表示把 $pos$ 号节点的点权修改为 $val$，点的编号从 $0$ 开始。 对于每一个询问 $2$ ，请输出操作的结果 $mod$ $p$，$p$ 为质数。 Solution考虑每个节点对答案的贡献：显然总方案数为$$\prod_{i=0}^{n-1} a_i$$显然若第 $i$ 号节点的 $a_i &lt; val$ ，则 $i$ 节点对答案贡献为 $0$若第 $i$ 号节点 $a[i] &gt;= val$ ，则 $i$ 节点对答案的贡献为$$\frac{\prod_{i=0}^{n-1}a_i}{a_i}$$ 考虑一次询问，我们要求的就是： $$\frac{\prod_{i=0}^{n-1}a_i}{a_{i1}} + \frac{\prod_{i=0}^{n-1}a_i}{a_{i2}} + \frac{\prod_{i=0}^{n-1}a_i}{a_{i3}} + \cdots + \frac{\prod_{i=0}^{n-1}a_i}{a_{im}}$$ 并且 $$a_{i1},a_{i2},a_{i3},\cdots,a_{im} &gt;= val$$ 这显然是不能快速求的。观察题目发现 $p$ 为质数，考虑使用费马小定理求解，则得到： $$\prod_{i=0}^{n-1}a_i \times (a_{i1}^{mod - 2} + a_{i2}^{mod - 2} + \cdots + a_{im}^{mod - 2})$$ 有人可能会说： Wen_kr, 你这样不会重复累计吗？ 实际上并不会，由于$$\prod_{i=0}^{n-1}a_i \times a_{i1}^{mod-2}$$累积的是当 $a_{i1}$ 为 $val$ 时对答案的贡献，即在其他所有情况时， $a_{i1}$ 对答案的贡献，因此，这样的统计是无重复无遗漏的。 这样一来，我们只需要把 $a_{i}^{mod - 2}$ 用数据结构维护起来就可以求解了！考虑使用线段树。把所有的 $a_i$ 与所有询问的 $val$ 插入同一个数组排序，再把数组 $unique$ 一下，我们设现在的数组大小为 $tot$ ，修改操作，我们把 $a_i$ $lowerbound$ 一下，在 $lowerbound$ 的位置处修改。对于查询操作，我们把查询的 $val$ $lowerbound$ 一下，设$lowerbound$结果为 $p$，则最终结果即为从 $p$ 到 $tot$ 所有元素的和。这样使用线段树就十分方便。 接着考虑操作 $2$ 线段树的修改是很好完成的，只需要回滚一次+修改一次即可得到解。 就只剩下一个问题：怎么维护新的累乘之积。 考虑使用费马小定理，新的累乘之和即为： $$\prod_{i=0}^{n-1}a_i \times a_{pos}^{mod - 2} \times val$$ 就可以完成啦…吗？ 当你欣喜地写完程序，测完样例，却发现，样例都无法过去…… 因此，我们目前的方法，仍然有严重的漏洞。 是什么呢？我们考虑一个数 $a_i$ ，假设$a_i \% mod = 0 $，当我们修改 $a_i$ 回滚操作的时候，能显然发现这样是不对的，因为这样回滚，就是把累乘之积除上了一个 $0$ ! 考虑用一个新的变量 $c$ 来记录当前序列中有多少个 $a_i$ 使 $a_i \% mod = 0$新开一棵线段树，维护一段区间内有多少个 $a_i$ 满足这个条件。对于每个满足条件的 $a_i$ ，因为 $a_i^{mod - 2} = 0$ ，因此我们没有必要将它插入原线段树，并且因为乘了 $a_i$ 之后，我们维护累乘之积的变量会始终为零并会出现错误，因此累计累乘时也不累计 $a_i$。 查询操作，若 $c = 0$ ，我们就像如上文所述的查询查值。若 $c = 1$ ，我们在 $p$ 到 $tot$ 上求一遍有多少个 $a_i$ 满足条件，$p$的意义如上文所述。这样一来，假如查询的结果为 $0$ ，那么无论如何，累乘的结果 $ \% mod$ 始终为 $0$ ，这样结果为 $0$否则由于当且仅当 $a_i$ ($a_i$ 符合上文条件) 对答案的贡献为 $1$，即当 $a_i = val$ 时，我们的答案才有值，因此答案为 $\prod_{i=0}^{n-1}a_i,a_i\text{不符合上文条件}$可以看出这个答案为上文的累乘之和。 若$c &gt; 1$ 无论我们把哪个值对累乘的贡献置为 $1$，让其等于 $val$，最终的结果均为 $0$ 对于修改操作，若被修改的原值 $\% mod = 0$，我们则更新 $c$ 值与另一棵线段树的值，否则则按原操作方法处理。对于修改后的值，我们同样考虑其 $\% mod%$ 的值，分类处理即可。 AC Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;long long all[400050],a[400050];long long tot,sum[800050],cnt[800050];long long mod,n,q,t,c;struct Caozuo&#123; long long op,pos,val;&#125;op[400050];long long qpow(long long base,long long tms)&#123; long long tmp = 1; base %= mod; while(tms) &#123; if(tms &amp; 1) tmp = tmp * base % mod; base = base * base % mod; tms &gt;&gt;= 1; &#125; return tmp;&#125;void Update(long long val[],long long rt,long long pos,long long l,long long r,long long valx)&#123; if(l == r) &#123; val[rt] = ((val[rt] + valx) % mod + mod) % mod; return ; &#125; long long mid = (l + r) &gt;&gt; 1; if(mid &gt;= pos) Update(val,rt &lt;&lt; 1,pos,l,mid,valx); else Update(val,rt &lt;&lt; 1 | 1,pos,mid + 1,r,valx); val[rt] = val[rt &lt;&lt; 1] + val[rt &lt;&lt; 1 | 1]; val[rt] %= mod;&#125;long long Query(long long val[],long long rt,long long l,long long r,long long l1,long long r1)&#123; if(l &gt;= l1 &amp;&amp; r &lt;= r1) return val[rt] % mod; long long mid = (l + r) &gt;&gt; 1; long long tmp = 0; if(mid &gt;= l1) tmp = (tmp + Query(val,rt &lt;&lt; 1,l,mid,l1,r1)) % mod; if(mid &lt; r1) tmp = (tmp + Query(val,rt &lt;&lt; 1 | 1,mid + 1,r,l1,r1)) % mod; return tmp;&#125;void Input()&#123; tot = 0; memset(sum,0,sizeof(sum));memset(cnt,0,sizeof(cnt)); scanf("%lld%lld%lld",&amp;n,&amp;mod,&amp;q); for(long long i = 1;i &lt;= n; ++ i) &#123; scanf("%lld",&amp;a[i]); all[++tot] = a[i]; &#125; for(long long i = 1;i &lt;= q; ++ i) &#123; scanf("%lld",&amp;op[i].op); if(op[i].op == 1) &#123; scanf("%lld",&amp;op[i].val); all[++tot] = op[i].val; &#125; else &#123; scanf("%lld%lld",&amp;op[i].pos,&amp;op[i].val); all[++tot] = op[i].val; op[i].pos ++; &#125; &#125;&#125;void Work()&#123; sort(all + 1,all + tot + 1); long long mul = 1; c = 0; tot = unique(all + 1,all + tot + 1) - all - 1; for(long long i = 1;i &lt;= n; ++ i) &#123; long long p = lower_bound(all + 1,all + 1 + tot,a[i]) - all; if(a[i] % mod == 0) &#123; c ++; Update(cnt,1,p,1,tot,1); &#125; else &#123; mul = mul * a[i] % mod; Update(sum,1,p,1,tot,qpow(a[i],mod - 2)); &#125; &#125; for(long long i = 1;i &lt;= q; ++ i) &#123; long long val = op[i].val; long long p = lower_bound(all + 1,all + 1 + tot,val) - all; if(op[i].op == 1) &#123; if(c == 0) printf("%lld\n",mul * Query(sum,1,1,tot,p,tot) % mod); else if(c == 1) &#123; if(Query(cnt,1,1,tot,p,tot) &gt; 0) printf("%lld\n",mul); else printf("0\n"); &#125; else printf("0\n"); &#125; else &#123; long long pos = op[i].pos; long long px = lower_bound(all + 1,all + 1 + tot,a[pos]) - all; if(a[pos] % mod == 0) &#123; c --; Update(cnt,1,px,1,tot,-1); &#125; else &#123; mul = mul * qpow(a[pos],mod - 2) % mod; Update(sum,1,px,1,tot,-qpow(a[pos],mod - 2)); &#125; if(val % mod == 0) &#123; c ++; Update(cnt,1,p,1,tot,1); &#125; else &#123; mul = mul * val % mod; Update(sum,1,p,1,tot,qpow(val,mod - 2)); &#125; a[pos] = val; &#125; &#125;&#125;int main()&#123; long long T; scanf("%lld",&amp;T); while(T--) &#123; Input(); Work(); &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等比矩阵求和的另一种思路]]></title>
    <url>%2F2018%2F04%2F07%2FDB%2F</url>
    <content type="text"><![CDATA[引言当我们对一个矩阵进行快速幂时，我们可能需要对矩阵的某一行进行求和，即计算矩阵 $A$ $A^1 + A^2 + A^3 + A^4 + A^5 + \ldots + A^n$ 中的第一行的和。 如何解决？ 考虑对矩阵右侧加一行 $1$例如，假设原矩阵是$$\begin{bmatrix}a_1&amp;a_2\\a_3&amp;a_4\\\end{bmatrix}$$对于矩阵转换后，我们有:$$\begin{bmatrix}a_1&amp;a_2&amp;1\\a_3&amp;a_4&amp;1\\0&amp;0&amp;1\\\end{bmatrix}$$考虑对这个矩阵进行乘方矩阵的二次幂为$$\begin{bmatrix}a_1^2+a_2a_3+0&amp;a_1a_2+a_2a_4+0&amp;a_1+a_2+1\\a_1a_3+a_3a_4+0&amp;a_2a_3+a_4^2+0&amp;a_3+a_4+1\\0+0+0&amp;0+0+0&amp;0+0+1\\\end{bmatrix}$$首先我们可以观察到 右侧增加的一行1对矩阵的本身乘方无影响其次，考虑右侧的一列的数值，可发现其数值等于第一行的 $1$ 次方的和。由矩阵乘法的性质：最右一列的值在数值上等于对应列的第一个元素+对应列的第二个元素+对应列的第三个元素+…+1 考虑再乘一次转换后的矩阵，我们可以得到一个喜闻乐见的性质：最右一列的数值，等于该矩阵的一次方的对应行的和 + 该矩阵二次方的对应行的和 + 1 至此，我们的问题已经解决，最后某一行的和，就等于对应行的和减去 $1$ 为什么这样做是正确的首先，我们在末尾一行补了 $0$ ，这样便不会影响到原矩阵的乘法(即最后的一项始终是 $0$) 其次，最后一行的值在矩阵乘法中不会发生变化，该为 $0$ 的始终为 $0$ ，为 $1$ 的始终为 $1$ 最后，我们考虑最后一列的值，以第一行举例：在第一次乘方后，数值上等于 第一行矩阵各元素的和 + 1第二次乘方前，由于第一行除了最后一列外所有的元素均为原本矩阵二次幂后的值，因此最后一列数值上等于 原本矩阵第一行二次幂后的值 + 原本矩阵一次幂后的值 + 1.此时考虑原矩阵，最后一列的值已经不是 $1$ 而是一次幂元素的和 + 1，因此 $1$ 不会被重复累计。 这样乘下去，最终第一行前 $n$ 次幂的和会等于矩阵第一行的和 - 1]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>数论</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, World!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
