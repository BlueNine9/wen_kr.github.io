<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello, World!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[$$Hello, Coding!$$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;struct edge&#123; int v,nxt;&#125;e[200050];int ecnt,head[100050];int n,q;void adde(int u,int v)&#123; e[++ecnt].v = v; e[ecnt].nxt = head[u]; head[u] = ecnt;&#125;int dep[100050],fa[100050],top[100050],son[100050],sz[100050],ps[100050],rnk[100050];int pcnt;void dfs1(int pos,int lst)&#123; dep[pos] = dep[lst] + 1; fa[pos] = lst; sz[pos] = 1; for(int i = head[pos];i;i = e[i].nxt) &#123; int v = e[i].v; if(v != lst) &#123; dfs1(v,pos); sz[pos] += sz[v]; if(!son[pos] || sz[v] &gt; sz[son[pos]]) son[pos] = v; &#125; &#125;&#125;void dfs2(int pos,int tp)&#123; top[pos] = tp; ps[pos] = ++pcnt; rnk[pcnt] = pos; if(son[pos]) dfs2(son[pos],tp); for(int i = head[pos];i;i = e[i].nxt) &#123; int v = e[i].v; if(v != son[pos] &amp;&amp; v != fa[pos]) dfs2(v,v); &#125;&#125;struct Segment_Tree&#123; int sum,lazy;&#125;tree[400050];void Push_Up(int rt)&#123; tree[rt].sum = (tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum);&#125;void Push_Down(int rt,int l1,int r1,int l2,int r2)&#123; if(tree[rt].lazy != -1) &#123; tree[rt &lt;&lt; 1].sum = (r1 - l1 + 1) * tree[rt].lazy; tree[rt &lt;&lt; 1 | 1].sum = (r2 - l2 + 1) * tree[rt].lazy; tree[rt &lt;&lt; 1].lazy = tree[rt &lt;&lt; 1 | 1].lazy = tree[rt].lazy; tree[rt].lazy = -1; &#125;&#125;void Build(int rt,int l,int r)&#123; tree[rt].lazy = -1; if(l == r) &#123; return ; &#125; int mid = (l + r) &gt;&gt; 1; Build(rt &lt;&lt; 1,l,mid); Build(rt &lt;&lt; 1 | 1,mid + 1,r); &#125;void Update(int rt,int l,int r,int l1,int r1,int sum)&#123; if(l &gt;= l1 &amp;&amp; r &lt;= r1) &#123; tree[rt].sum = (r - l + 1) * sum; tree[rt].lazy = sum; return ; &#125; int mid = (l + r) &gt;&gt; 1; Push_Down(rt,l,mid,mid + 1,r); if(mid &gt;= l1) Update(rt &lt;&lt; 1,l,mid,l1,r1,sum); if(mid &lt; r1) Update(rt &lt;&lt; 1 | 1,mid + 1,r,l1,r1,sum); Push_Up(rt);&#125;int Query(int rt,int l,int r,int l1,int r1,int sum)&#123; if(l &gt;= l1 &amp;&amp; r &lt;= r1) &#123; if(sum == 0) return (r - l + 1) - tree[rt].sum; else return tree[rt].sum; &#125; int mid = (l + r) &gt;&gt; 1; Push_Down(rt,l,mid,mid + 1,r); int tmp = 0; if(mid &gt;= l1) tmp += Query(rt &lt;&lt; 1,l,mid,l1,r1,sum); if(mid &lt; r1) tmp += Query(rt &lt;&lt; 1 | 1,mid + 1,r,l1,r1,sum);// Push_Up(rt); return tmp;&#125;void Update(int pos,int sum)&#123; while(top[pos] != 1) &#123; Update(1,1,n,ps[top[pos]],ps[pos],sum); pos = fa[top[pos]]; &#125; Update(1,1,n,ps[1],ps[pos],sum);&#125;int Query(int pos,int sum)&#123; int sumx = 0; while(top[pos] != 1) &#123; sumx += Query(1,1,n,ps[top[pos]],ps[pos],sum); pos = fa[top[pos]]; &#125; sumx += Query(1,1,n,ps[1],ps[pos],sum); return sumx;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 2;i &lt;= n; ++ i) &#123; int u; scanf("%d",&amp;u); u ++; adde(u,i),adde(i,u); &#125; dfs1(1,0); dfs2(1,1); scanf("%d",&amp;q); Build(1,1,n); while(q--) &#123; char ch[20]; scanf(" %s",ch); if(ch[0] == 'i') &#123; int u; scanf("%d",&amp;u); u ++; printf("%d\n",Query(u,0)); Update(u,1); &#125; else &#123; int u; scanf("%d",&amp;u); u ++; printf("%d\n",Query(1,1,n,ps[u],ps[u] + sz[u] - 1,1)); Update(1,1,n,ps[u],ps[u] + sz[u] - 1,0); &#125; &#125;&#125;]]></content>
  </entry>
</search>
