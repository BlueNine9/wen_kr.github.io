<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How Many Hougong]]></title>
    <url>%2F2018%2F04%2F07%2FHow-many-hougong%2F</url>
    <content type="text"><![CDATA[题目简述给定一串长度为 $n$ 的序列，每个点上有一个权值 $a_i$ ，现在你需要处理 $q$ 个操作，有以下两种操作： $1 val$ 表示你需要构造一个序列，序列中每一个元素 $seq_i$ 小于等于 $a_i$ 且大于 $0$，问所有合法的序列中 $val$ 出现了几次。 $2 pos val$ 表示把 $pos$ 号节点的点权修改为 $val$，点的编号从 $0$ 开始。 对于每一个询问 $2$ ，请输出操作的结果 $mod p$，$p$ 为质数。 Solution考虑每个节点对答案的贡献：显然总方案数为$$\prod_{i=0}^{n-1} a_i$$显然若第 $i$ 号节点的 $a_i &lt; val$ ，则 $i$ 节点对答案贡献为 $0$若第 $i$ 号节点 $a[i] &gt;= val$ ，则 $i$ 节点对答案的贡献为$$\frac{\prod_{i=0}^{n-1}a_i}{a_i}$$ 考虑一次询问，我们要求的就是： $$\frac{\prod_{i=0}^{n-1}a_i}{a_{i1}} + \frac{\prod_{i=0}^{n-1}a_i}{a_{i2}} + \frac{\prod_{i=0}^{n-1}a_i}{a_{i3}} + \cdots + \frac{\prod_{i=0}^{n-1}a_i}{a_{im}}$$ 并且 $$a_{i1},a_{i2},a_{i3},\cdots,a_{im} &gt;= val$$ 这显然是不能快速求的。观察题目发现 $p$ 为质数，考虑使用费马小定理求解，则得到： $$\prod_{i=0}^{n-1}a_i \times (a_{i1}^{mod - 2} + a_{i2}^{mod - 2} + \cdots + a_{im}^{mod - 2})$$ 有人可能会说： Wen_kr, 你这样不会重复累计吗？ 实际上并不会，由于$$\prod_{i=0}^{n-1}a_i \times a_{i1}^{mod-2}$$累积的是当 $a_{i1}$ 为 $val$ 时对答案的贡献，即在其他所有情况时， $a_{i1}$ 对答案的贡献，因此，这样的统计是无重复无遗漏的。 这样一来，我们只需要把 $a_{i}^{mod - 2}$ 用数据结构维护起来就可以求解了！考虑使用线段树。把所有的 $a_i$ 与所有询问的 $val$ 插入同一个数组排序，再把数组 $unique$ 一下，我们设现在的数组大小为 $tot$ ，修改操作，我们把 $a_i$ $lowerbound$ 一下，在 $lowerbound$ 的位置处修改。对于查询操作，我们把查询的 $val$ $lowerbound$ 一下，设$lowerbound$结果为 $p$，则最终结果即为从 $p$ 到 $tot$ 所有元素的和。这样使用线段树就十分方便。 接着考虑操作 $2$ 线段树的修改是很好完成的，只需要回滚一次+修改一次即可得到解。 就只剩下一个问题：怎么维护新的累乘之积。 考虑使用费马小定理，新的累乘之和即为： $$\prod_{i=0}^{n-1}a_i \times a_{pos}^{mod - 2} \times val$$ 就可以完成啦…吗？ 当你欣喜地写完程序，测完样例，却发现，样例都无法过去…… 因此，我们目前的方法，仍然有严重的漏洞。 是什么呢？我们考虑一个数 $a_i$ ，假设$a_i \% mod = 0 $，当我们修改 $a_i$ 回滚操作的时候，能显然发现这样是不对的，因为这样回滚，就是把累乘之积除上了一个 $0$ ! 考虑用一个新的变量 $c$ 来记录当前序列中有多少个 $a_i$ 使 $a_i \% mod = 0$新开一棵线段树，维护一段区间内有多少个 $a_i$ 满足这个条件。对于每个满足条件的 $a_i$ ，因为 $a_i^{mod - 2} = 0$ ，因此我们没有必要将它插入原线段树，并且因为乘了 $a_i$ 之后，我们维护累乘之积的变量会始终为零并会出现错误，因此累计累乘时也不累计 $a_i$。 查询操作，若 $c = 0$ ，我们就像如上文所述的查询查值。若 $c = 1$ ，我们在 $p$ 到 $tot$ 上求一遍有多少个 $a_i$ 满足条件，$p$的意义如上文所述。这样一来，假如查询的结果为 $0$ ，那么无论如何，累乘的结果 $ \% mod$ 始终为 $0$ ，这样结果为 $0$否则由于当且仅当 $a_i$ ($a_i$ 符合上文条件) 对答案的贡献为 $1$，即当 $a_i = val$ 时，我们的答案才有值，因此答案为 $\prod_{i=0}^{n-1}a_i,a_i\text{不符合上文条件}$可以看出这个答案为上文的累乘之和。 若$c &gt; 1$ 无论我们把哪个值对累乘的贡献置为 $1$，让其等于 $val$，最终的结果均为 $0$ 对于修改操作，若被修改的原值 $\% mod = 0$，我们则更新 $c$ 值与另一棵线段树的值，否则则按原操作方法处理。对于修改后的值，我们同样考虑其 $\% mod%$ 的值，分类处理即可。 AC Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;long long all[400050],a[400050];long long tot,sum[800050],cnt[800050];long long mod,n,q,t,c;struct Caozuo&#123; long long op,pos,val;&#125;op[400050];long long qpow(long long base,long long tms)&#123; long long tmp = 1; base %= mod; while(tms) &#123; if(tms &amp; 1) tmp = tmp * base % mod; base = base * base % mod; tms &gt;&gt;= 1; &#125; return tmp;&#125;void Update(long long val[],long long rt,long long pos,long long l,long long r,long long valx)&#123; if(l == r) &#123; val[rt] = ((val[rt] + valx) % mod + mod) % mod; return ; &#125; long long mid = (l + r) &gt;&gt; 1; if(mid &gt;= pos) Update(val,rt &lt;&lt; 1,pos,l,mid,valx); else Update(val,rt &lt;&lt; 1 | 1,pos,mid + 1,r,valx); val[rt] = val[rt &lt;&lt; 1] + val[rt &lt;&lt; 1 | 1]; val[rt] %= mod;&#125;long long Query(long long val[],long long rt,long long l,long long r,long long l1,long long r1)&#123; if(l &gt;= l1 &amp;&amp; r &lt;= r1) return val[rt] % mod; long long mid = (l + r) &gt;&gt; 1; long long tmp = 0; if(mid &gt;= l1) tmp = (tmp + Query(val,rt &lt;&lt; 1,l,mid,l1,r1)) % mod; if(mid &lt; r1) tmp = (tmp + Query(val,rt &lt;&lt; 1 | 1,mid + 1,r,l1,r1)) % mod; return tmp;&#125;void Input()&#123; tot = 0; memset(sum,0,sizeof(sum));memset(cnt,0,sizeof(cnt)); scanf("%lld%lld%lld",&amp;n,&amp;mod,&amp;q); for(long long i = 1;i &lt;= n; ++ i) &#123; scanf("%lld",&amp;a[i]); all[++tot] = a[i]; &#125; for(long long i = 1;i &lt;= q; ++ i) &#123; scanf("%lld",&amp;op[i].op); if(op[i].op == 1) &#123; scanf("%lld",&amp;op[i].val); all[++tot] = op[i].val; &#125; else &#123; scanf("%lld%lld",&amp;op[i].pos,&amp;op[i].val); all[++tot] = op[i].val; op[i].pos ++; &#125; &#125;&#125;void Work()&#123; sort(all + 1,all + tot + 1); long long mul = 1; c = 0; tot = unique(all + 1,all + tot + 1) - all - 1; for(long long i = 1;i &lt;= n; ++ i) &#123; long long p = lower_bound(all + 1,all + 1 + tot,a[i]) - all; if(a[i] % mod == 0) &#123; c ++; Update(cnt,1,p,1,tot,1); &#125; else &#123; mul = mul * a[i] % mod; Update(sum,1,p,1,tot,qpow(a[i],mod - 2)); &#125; &#125; for(long long i = 1;i &lt;= q; ++ i) &#123; long long val = op[i].val; long long p = lower_bound(all + 1,all + 1 + tot,val) - all; if(op[i].op == 1) &#123; if(c == 0) printf("%lld\n",mul * Query(sum,1,1,tot,p,tot) % mod); else if(c == 1) &#123; if(Query(cnt,1,1,tot,p,tot) &gt; 0) printf("%lld\n",mul); else printf("0\n"); &#125; else printf("0\n"); &#125; else &#123; long long pos = op[i].pos; long long px = lower_bound(all + 1,all + 1 + tot,a[pos]) - all; if(a[pos] % mod == 0) &#123; c --; Update(cnt,1,px,1,tot,-1); &#125; else &#123; mul = mul * qpow(a[pos],mod - 2) % mod; Update(sum,1,px,1,tot,-qpow(a[pos],mod - 2)); &#125; if(val % mod == 0) &#123; c ++; Update(cnt,1,p,1,tot,1); &#125; else &#123; mul = mul * val % mod; Update(sum,1,p,1,tot,qpow(val,mod - 2)); &#125; a[pos] = val; &#125; &#125;&#125;int main()&#123; long long T; scanf("%lld",&amp;T); while(T--) &#123; Input(); Work(); &#125;&#125;]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等比矩阵求和的另一种思路]]></title>
    <url>%2F2018%2F04%2F07%2FDB%2F</url>
    <content type="text"><![CDATA[引言当我们对一个矩阵进行快速幂时，我们可能需要对矩阵的某一行进行求和，即计算矩阵 $A$ $A^1 + A^2 + A^3 + A^4 + A^5 + \ldots + A^n$ 中的第一行的和。 如何解决？ 考虑对矩阵右侧加一行 $1$例如，假设原矩阵是$$\begin{bmatrix}a_1&amp;a_2\\a_3&amp;a_4\\\end{bmatrix}$$对于矩阵转换后，我们有:$$\begin{bmatrix}a_1&amp;a_2&amp;1\\a_3&amp;a_4&amp;1\\0&amp;0&amp;1\\\end{bmatrix}$$考虑对这个矩阵进行乘方矩阵的二次幂为$$\begin{bmatrix}a_1^2+a_2a_3+0&amp;a_1a_2+a_2a_4+0&amp;a_1+a_2+1\\a_1a_3+a_3a_4+0&amp;a_2a_3+a_4^2+0&amp;a_3+a_4+1\\0+0+0&amp;0+0+0&amp;0+0+1\\\end{bmatrix}$$首先我们可以观察到 右侧增加的一行1对矩阵的本身乘方无影响其次，考虑右侧的一列的数值，可发现其数值等于第一行的 $1$ 次方的和。由矩阵乘法的性质：最右一列的值在数值上等于对应列的第一个元素+对应列的第二个元素+对应列的第三个元素+…+1 考虑再乘一次转换后的矩阵，我们可以得到一个喜闻乐见的性质：最右一列的数值，等于该矩阵的一次方的对应行的和 + 该矩阵二次方的对应行的和 + 1 至此，我们的问题已经解决，最后某一行的和，就等于对应行的和减去 $1$ 为什么这样做是正确的首先，我们在末尾一行补了 $0$ ，这样便不会影响到原矩阵的乘法(即最后的一项始终是 $0$) 其次，最后一行的值在矩阵乘法中不会发生变化，该为 $0$ 的始终为 $0$ ，为 $1$ 的始终为 $1$ 最后，我们考虑最后一列的值，以第一行举例：在第一次乘方后，数值上等于 第一行矩阵各元素的和 + 1第二次乘方前，由于第一行除了最后一列外所有的元素均为原本矩阵二次幂后的值，因此最后一列数值上等于 原本矩阵第一行二次幂后的值 + 原本矩阵一次幂后的值 + 1.此时考虑原矩阵，最后一列的值已经不是 $1$ 而是一次幂元素的和 + 1，因此 $1$ 不会被重复累计。 这样乘下去，最终第一行前 $n$ 次幂的和会等于矩阵第一行的和 - 1]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
        <tag>数论</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, World!]]></title>
    <url>%2F2018%2F04%2F07%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
